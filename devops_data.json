[
    {
        "problem": "How do I create a secure multi-stage Dockerfile for a Python Flask application?",
        "solution": "Here's a secure multi-stage Dockerfile for Python Flask:\n\n```dockerfile\n# Build stage\nFROM python:3.11-slim AS builder\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    build-essential \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements and install Python packages\nCOPY requirements.txt .\nRUN pip install --no-cache-dir --user -r requirements.txt\n\n# Runtime stage\nFROM python:3.11-slim AS runtime\n\n# Create non-root user\nRUN groupadd -r flask && useradd -r -g flask flask\n\n# Install only runtime dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    curl \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy Python packages from builder\nCOPY --from=builder /root/.local /home/flask/.local\n\n# Set up application\nWORKDIR /app\nCOPY --chown=flask:flask . .\n\n# Switch to non-root user\nUSER flask\n\n# Add user's local bin to PATH\nENV PATH=/home/flask/.local/bin:$PATH\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:5000/health || exit 1\n\nEXPOSE 5000\n\n# Use gunicorn for production\nCMD [\"gunicorn\", \"--bind\", \"0.0.0.0:5000\", \"--workers\", \"3\", \"--timeout\", \"120\", \"app:app\"]\n```\n\nKey security features:\n- Multi-stage build reduces final image size by ~60%\n- Non-root user (flask) for runtime security\n- Slim base image instead of Alpine for better Python compatibility\n- Layer caching optimization with requirements.txt first\n- Health check for container orchestration\n- Proper cleanup of package manager cache\n- Production WSGI server (gunicorn) instead of Flask dev server\n- Secure user permissions and file ownership",
        "category": "docker",
        "difficulty": "intermediate"
    },
    {
        "problem": "How do I create a multi-stage Dockerfile for a Node.js application that minimizes image size?",
        "solution": "Here's an optimized multi-stage Dockerfile for Node.js:\n\n```dockerfile\n# Build stage\nFROM node:18-alpine AS builder\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production --silent \\\n    && npm cache clean --force\n\n# Production stage\nFROM node:18-alpine AS runtime\n\n# Install dumb-init for signal handling\nRUN apk add --no-cache dumb-init\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs \\\n    && adduser -S -u 1001 -G nodejs nodejs\n\n# Set working directory\nWORKDIR /app\n\n# Copy production dependencies from builder\nCOPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules\n\n# Copy application code\nCOPY --chown=nodejs:nodejs . .\n\n# Remove package files to reduce attack surface\nRUN rm -f package*.json\n\n# Switch to non-root user\nUSER nodejs\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:3000/health || exit 1\n\nEXPOSE 3000\n\n# Use dumb-init to handle signals properly\nENTRYPOINT [\"dumb-init\", \"--\"]\nCMD [\"node\", \"server.js\"]\n```\n\nKey optimizations:\n- Multi-stage build reduces final image size\n- Alpine Linux for minimal footprint\n- Non-root user (nodejs) for security\n- Signal handling with dumb-init\n- Production-only dependencies\n- Proper file ownership and permissions\n- Health check for container orchestration\n- Clean package manager cache",
        "category": "docker",
        "difficulty": "intermediate"
    },
    {
        "problem": "Design a Kubernetes deployment with proper resource limits, health checks, and rolling updates for a web application",
        "solution": "Here's a production-ready Kubernetes deployment:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp-deployment\n  labels:\n    app: webapp\n    version: v1\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  selector:\n    matchLabels:\n      app: webapp\n  template:\n    metadata:\n      labels:\n        app: webapp\n        version: v1\n    spec:\n      containers:\n      - name: webapp\n        image: webapp:v1.2.3\n        ports:\n        - containerPort: 8080\n          name: http\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n          timeoutSeconds: 3\n          failureThreshold: 3\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        - name: PORT\n          value: \"8080\"\n        securityContext:\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n          runAsNonRoot: true\n          runAsUser: 1001\n        volumeMounts:\n        - name: tmp-volume\n          mountPath: /tmp\n      volumes:\n      - name: tmp-volume\n        emptyDir: {}\n      securityContext:\n        fsGroup: 1001\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\n  labels:\n    app: webapp\nspec:\n  selector:\n    app: webapp\n  ports:\n  - port: 80\n    targetPort: 8080\n    protocol: TCP\n    name: http\n  type: ClusterIP\n```\n\nThis deployment ensures:\n- Rolling updates with zero downtime (maxUnavailable: 1, maxSurge: 1)\n- Proper resource management with requests and limits\n- Health monitoring with liveness and readiness probes\n- Multiple replicas (3) for high availability\n- Security context with non-root user\n- Read-only root filesystem for security\n- Proper probe timeouts and failure thresholds",
        "category": "kubernetes",
        "difficulty": "intermediate"
    },
    {
        "problem": "Create a GitHub Actions workflow for a Python application with testing, security scanning, and deployment",
        "solution": "Here's a comprehensive GitHub Actions workflow:\n\n```yaml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\nenv:\n  PYTHON_VERSION: '3.11'\n  NODE_VERSION: '18'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.9', '3.10', '3.11']\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n    \n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    \n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n        path: ~/.cache/pip\n        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n        restore-keys: |\n          ${{ runner.os }}-pip-\n    \n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n        pip install pytest pytest-cov bandit safety flake8\n    \n    - name: Lint with flake8\n      run: |\n        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics\n        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics\n    \n    - name: Run tests with coverage\n      run: |\n        pytest --cov=./src --cov-report=xml --cov-report=html\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n        flags: unittests\n        name: codecov-umbrella\n\n  security:\n    runs-on: ubuntu-latest\n    needs: test\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n    \n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ env.PYTHON_VERSION }}\n    \n    - name: Install security tools\n      run: |\n        pip install bandit safety\n    \n    - name: Run Bandit security scan\n      run: |\n        bandit -r ./src -f json -o bandit-report.json || true\n    \n    - name: Run Safety dependency scan\n      run: |\n        safety check --json --output safety-report.json || true\n    \n    - name: Upload security reports\n      uses: actions/upload-artifact@v3\n      with:\n        name: security-reports\n        path: |\n          bandit-report.json\n          safety-report.json\n\n  build:\n    runs-on: ubuntu-latest\n    needs: [test, security]\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n    \n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n    \n    - name: Login to Docker Hub\n      uses: docker/login-action@v3\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n    \n    - name: Build and push Docker image\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        push: true\n        tags: |\n          myapp:latest\n          myapp:${{ github.sha }}\n        cache-from: type=gha\n        cache-to: type=gha,mode=max\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.ref == 'refs/heads/main'\n    environment: production\n    \n    steps:\n    - name: Deploy to production\n      run: |\n        echo \"Deploying to production...\"\n        # Add your deployment commands here\n        # kubectl apply -f k8s/\n        # helm upgrade myapp ./chart\n```\n\nFeatures included:\n- Matrix testing across Python versions (3.9, 3.10, 3.11)\n- Code linting with flake8\n- Test coverage reporting with pytest-cov\n- Security scanning with Bandit (SAST) and Safety (dependency scan)\n- Dependency caching for faster builds\n- Docker image building and pushing\n- Conditional deployment only on main branch\n- Environment protection for production deployment\n- Artifact uploading for security reports",
        "category": "cicd",
        "difficulty": "intermediate"
    },
    {
        "problem": "Write Terraform configuration for an AWS ECS cluster with load balancer",
        "solution": "Here's a complete Terraform configuration for AWS ECS with ALB:\n\n```hcl\n# Variables\nvariable \"cluster_name\" {\n  description = \"Name of the ECS cluster\"\n  type        = string\n  default     = \"my-ecs-cluster\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for VPC\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\n# Data sources\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\ndata \"aws_ami\" \"ecs_optimized\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n  \n  filter {\n    name   = \"name\"\n    values = [\"amzn2-ami-ecs-hvm-*-x86_64-ebs\"]\n  }\n}\n\n# VPC Configuration\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n  \n  tags = {\n    Name = \"${var.cluster_name}-vpc\"\n  }\n}\n\n# Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"${var.cluster_name}-igw\"\n  }\n}\n\n# Public Subnets\nresource \"aws_subnet\" \"public\" {\n  count             = 2\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = \"10.0.${count.index + 1}.0/24\"\n  availability_zone = data.aws_availability_zones.available.names[count.index]\n  \n  map_public_ip_on_launch = true\n  \n  tags = {\n    Name = \"${var.cluster_name}-public-${count.index + 1}\"\n    Type = \"Public\"\n  }\n}\n\n# Route Table\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n  \n  tags = {\n    Name = \"${var.cluster_name}-public-rt\"\n  }\n}\n\n# Route Table Association\nresource \"aws_route_table_association\" \"public\" {\n  count          = length(aws_subnet.public)\n  subnet_id      = aws_subnet.public[count.index].id\n  route_table_id = aws_route_table.public.id\n}\n\n# Security Group for ALB\nresource \"aws_security_group\" \"alb\" {\n  name_prefix = \"${var.cluster_name}-alb-\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"${var.cluster_name}-alb-sg\"\n  }\n}\n\n# Security Group for ECS Tasks\nresource \"aws_security_group\" \"ecs_tasks\" {\n  name_prefix = \"${var.cluster_name}-ecs-tasks-\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port       = 0\n    to_port         = 65535\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.alb.id]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"${var.cluster_name}-ecs-tasks-sg\"\n  }\n}\n\n# Application Load Balancer\nresource \"aws_lb\" \"main\" {\n  name               = var.cluster_name\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.alb.id]\n  subnets            = aws_subnet.public[*].id\n  \n  enable_deletion_protection = false\n  \n  tags = {\n    Name = \"${var.cluster_name}-alb\"\n  }\n}\n\n# Target Group\nresource \"aws_lb_target_group\" \"app\" {\n  name        = \"${var.cluster_name}-tg\"\n  port        = 80\n  protocol    = \"HTTP\"\n  vpc_id      = aws_vpc.main.id\n  target_type = \"ip\"\n  \n  health_check {\n    enabled             = true\n    healthy_threshold   = 2\n    interval            = 30\n    matcher             = \"200\"\n    path                = \"/health\"\n    port                = \"traffic-port\"\n    protocol            = \"HTTP\"\n    timeout             = 5\n    unhealthy_threshold = 2\n  }\n  \n  tags = {\n    Name = \"${var.cluster_name}-tg\"\n  }\n}\n\n# ALB Listener\nresource \"aws_lb_listener\" \"web\" {\n  load_balancer_arn = aws_lb.main.arn\n  port              = \"80\"\n  protocol          = \"HTTP\"\n  \n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app.arn\n  }\n}\n\n# ECS Cluster\nresource \"aws_ecs_cluster\" \"main\" {\n  name = var.cluster_name\n  \n  configuration {\n    execute_command_configuration {\n      logging = \"OVERRIDE\"\n      \n      log_configuration {\n        cloud_watch_encryption_enabled = true\n        cloud_watch_log_group_name     = aws_cloudwatch_log_group.ecs.name\n      }\n    }\n  }\n  \n  tags = {\n    Name = var.cluster_name\n  }\n}\n\n# CloudWatch Log Group\nresource \"aws_cloudwatch_log_group\" \"ecs\" {\n  name              = \"/ecs/${var.cluster_name}\"\n  retention_in_days = 30\n  \n  tags = {\n    Name = \"${var.cluster_name}-logs\"\n  }\n}\n\n# ECS Task Execution Role\nresource \"aws_iam_role\" \"ecs_task_execution_role\" {\n  name = \"${var.cluster_name}-ecsTaskExecutionRole\"\n  \n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ecs_task_execution_role_policy\" {\n  role       = aws_iam_role.ecs_task_execution_role.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\"\n}\n\n# Outputs\noutput \"cluster_name\" {\n  description = \"Name of the ECS cluster\"\n  value       = aws_ecs_cluster.main.name\n}\n\noutput \"load_balancer_dns\" {\n  description = \"DNS name of the load balancer\"\n  value       = aws_lb.main.dns_name\n}\n\noutput \"target_group_arn\" {\n  description = \"ARN of the target group\"\n  value       = aws_lb_target_group.app.arn\n}\n```\n\nThis configuration provides:\n- Complete VPC setup with public subnets across AZs\n- Application Load Balancer with health checks\n- ECS cluster with CloudWatch logging\n- Proper security groups for ALB and ECS tasks\n- IAM roles for ECS task execution\n- Target group for service registration\n- Configurable variables for customization\n- Outputs for integration with other resources",
        "category": "iac",
        "difficulty": "advanced"
    },
    {
        "problem": "What are the essential security practices for containerized applications?",
        "solution": "Here are critical container security practices:\n\n**1. Image Security:**\n- Use official base images from trusted registries\n- Scan images for vulnerabilities with tools like Trivy, Clair\n- Implement image signing with Docker Content Trust\n\n**2. Runtime Security:**\n- Run containers as non-root users\n- Use read-only filesystems\n- Implement AppArmor/SELinux policies\n- Drop unnecessary capabilities\n\n**3. Secrets Management:**\n- Never embed secrets in images\n- Use Kubernetes secrets or external secret managers\n- Rotate secrets regularly\n\n**4. Network Security:**\n- Implement network policies\n- Use service mesh for mTLS\n- Segment networks properly",
        "category": "security",
        "difficulty": "intermediate"
    },
    {
        "problem": "How to implement Prometheus monitoring for microservices?",
        "solution": "Complete Prometheus setup:\n\n**prometheus.yml:**\n```yaml\nglobal:\n  scrape_interval: 15s\nscrape_configs:\n  - job_name: 'microservices'\n    kubernetes_sd_configs:\n      - role: endpoints\n```\n\n**Service metrics endpoint:**\n```python\nfrom prometheus_client import Counter, Histogram\nREQUEST_COUNT = Counter('requests_total', 'Total requests')\nREQUEST_LATENCY = Histogram('request_duration_seconds', 'Request latency')\n```",
        "category": "monitoring",
        "difficulty": "intermediate"
    }
]